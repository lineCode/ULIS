TilePool
list BlocksAwaitingDeletion
list BlocksAwaitingForClear
list BlocksAvailableForUsage
list BlocksDirtyInUseForWork


TiledBlock
    Map< coordinates_hash, macro_quadtree_chunk >
    └ macro_quadtree_chunk
        └ intermediate_quadtree_subdivision_chunk
                ├ filled_chunk:         ptr* to block covering the quadtree surface segment in TilePool 
                ├ empty_chunk:         ptr* to empty block in TilePool
                └ data_leaf_chunk:    ptr* to block covering the specified tile in TilePool

Single Image Creation and Manipulation Scenario:
    An Empty TiledBlock is created
    Its map is empty
    We fill a portion of the block on a rect that is a multiple of 64
    A fresh tile is requested in tile pool
    This tile is filled with fill color
    It is then moved to a dirty tiles list awaiting for later hash
    An entry is created with a chunk at coordinates_hash (0;0)
    The created entry is a filled_chunk, the ptr* value points the filled tile.
    A blend operation occurs somewhere in the same area
    The filled_chunk is recursively split into leafs, areas that are not impacted remains subdivised filled_chunks
    The impacted tile will be changed, first request a fresh tile from the pool, then copy the original filled contents into the fresh
    tile, then proceed to the blend operation.
    Move the processed tile to the dirty tiles list, awaiting for a later hashing to occur
    The same tile is subject to a new blend, query the ptr* and proceed, keep it in dirty list.
    Another adjacent tile is subject to a new blend, query ptr* original content, check refcount, it’s greater than one, so query a 
    fresh block, copy original contents and proceed to blend, store in dirty, check refcount 1.
    The block is cleared, remove all entries from the TiledBlock map, set refcounts to zero for targeted ptr*, set ptrs to
    BlocksAwaitingForClear list.
    The block is filled again but not on 64 bounds. Check the 8 possible geometric configuration of overlaping 64 tiles in borders
    and corners, fill-rect these 8 configurations and attribute ptrs* accordingly in dirty list while subdividing the quadtree entries
    appropriately.
    A blend operation occurs at the edge of 4 disting tiles, sequentially query original filed ptr, query fresh block, perform copy,
    perform blend OP, store in dirty list.

    OnTick at regular steps, allocate a few blocks in BlocksAwaitingForClear untile we reach the RAM cap.
                    , clear a few blocks in BlocksAwaitingForClear and move them to BlocksAvailableForUsage
                    , check if there are blocks in BlocksAwaitingDeletion and delete a few of them.
    Stope after a timer threshold is reached, continue on next iteration.

Sanitize TilePool and TiledBlocks Scenario:
    Sanitize runs CRC32 cached Hash check on a TiledBlock tiles. If there are empty tiles, replace them to empty     
    tile ptr, move empties to BlockAvailableForUsage
    TiledBlocks must be registered for current usage, lock / unlock
    TiledBlocks are sanitized upon unlock, sanitizing one TiledBlocks sanitizes all locked tiledBlocks.
    Sanitize Runs CRC32 on dirty tiles and moves them to hashmap CRC32 <=> ptr
    Tile entries in tile pools keeps tracks of who refers to it to update them if necessary
    Some TiledBlocks are registered for medio priority usage, their tiles are marked as BlocksAwaitingForRLE compression
    Compressed blocks are stored in BlocksRLECompressedForMediumPriorityUsage.
    If a medium priority block refers to a tile that is also refered by a high priority block, keep the refcount on this tile but do not 
    RLE compress it
    There are also low priority blocks, tiles in these low priority tiledblocks are RLE compressed and dumped on disk. If a low 
    priority refers to a medium priority, do not dump on disk keep refcount. If a low priority refers to a high priority, do not dump
    on disk, keep refcount.

TiledBlock OP & Geometry:
    a tiled block initialiy has no data and no size, upon OP on a tiled block, keep track of geometry of OP. The tiled block is then
    set to have the geometry of the OP.
    RoughMacroGeometry can be retrieved from the map.
    RoughTilesGeometry can also be retrieved from the quadtree structure.
    A finer grained geometry can also be obtained by running trim transparency alpha on the edges tiles.



===============================================================================================================================================
===============================================================================================================================================
===============================================================================================================================================
// RLE ENCODE:
#include <iostream>
#include <string>
using namespace std;

// Perform Run Length Encoding (RLE) data compression algorithm
// on string str
string encode(string str)
{
    // stores output string
    string encoding = "";
    int count;

    for (int i = 0; str[i]; i++)
    {
        // count occurrences of character at index i
        count = 1;
        while (str[i] == str[i + 1])
            count++, i++;

        // append current character and its count to the result
        encoding += to_string(count) + str[i];
    }

    return encoding;
}

// main function
int main()
{
    string str = "ABBCCCD";

    cout << encode(str);

    return 0;
}
===============================================================================================================================================
===============================================================================================================================================
===============================================================================================================================================